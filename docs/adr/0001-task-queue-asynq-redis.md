# ADR 0001: Выбор системы очередей: Asynq + Redis

## Статус
Принято

## Контекст
Сервису необходимо выполнять потенциально долгие HTTP-запросы к внешним провайдерам котировок (Frankfurter, ExchangeRate.host) в фоновом режиме, чтобы не блокировать HTTP-ответ пользователю и обеспечить надежность выполнения (retry в случае сетевых ошибок).

## Варианты

### 1. Горутины и каналы (native Go)
*   **Плюсы**: Нет внешних зависимостей, максимально быстро.
*   **Минусы**: Не подходит для распределенной среды и горизонтального масштабирования. Задачи теряются при перезагрузке сервиса (нет персистентности), сложно реализовать мониторинг и сложные стратегии повторов.

### 2. RabbitMQ / Kafka
*   **Плюсы**: Высокая надежность, мощные возможности маршрутизации, гарантии доставки.
*   **Минусы**: Избыточно для текущей задачи; требует поднятия и поддержки сложной инфраструктуры; Kafka сложна в настройке для небольших проектов.

### 3. Нативный database/sql polling (Transactional Outbox)
*   **Плюсы**: Транзакционная целостность с БД, нет дополнительных зависимостей кроме БД.
*   **Минусы**: Поллинг базы создает лишнюю нагрузку; нужно самостоятельно реализовывать логику воркеров, конкурентную обработку и повторы. В перспективе, мешает отделению обработчика в отдельный сервис (общая БД) и независимому масштабированию.

### 4. Asynq + Redis
*   **Плюсы**: Встроенные механизмы retry/timeout, доставка "at-least-once", наличие dashboard, минимальная инфраструктура, простой API.
*   **Минусы**: Зависимость от Redis; требует аккуратной настройки персистентности Redis.

## Решение
Выбран **Asynq** на базе **Redis**.

## Почему
1.  **Минимальный overhead**: Redis уже используется в проекте для кэширования котировок, поэтому добавление Asynq не требует новых инфраструктурных компонентов.
2.  **Надежность из коробки**: Asynq автоматически обрабатывает повторы с экспоненциальной задержкой, что критично при работе с нестабильными внешними API.
3.  **Изоляция**: В проекте используются два раздельных инстанса Redis (один для задач, другой для кэша), что позволяет настроить `noeviction` и персистентность только для очередей, гарантируя сохранность задач без риска OOM.
4.  **Скорость разработки**: Готовая библиотека позволяет сосредоточиться на бизнес-логике получения котировок, а не на управлении воркерами.

## Последствия
*   Необходимость поддержки Redis в инфраструктуре.
*   Возможность легкого масштабирования количества воркеров.
*   Наличие визуального контроля через asynqmon.
