# ADR 0002: Фоновое обновление котировок (async polling vs push)

## Статус
Принято

## Контекст
Нужно отдавать актуальные котировки при задержках и лимитах внешних провайдеров. Требуется выбрать стратегию взаимодействия клиента с API.

## Варианты

### 1. Синхронный запрос
Клиент делает `POST /quotes/update`, сервис ждет провайдера и возвращает котировку.
*   **Плюсы**: Простота для клиента.
*   **Минусы**: Блокировка клиента, риск тайм-аутов, сложная дедупликация.

### 2. WebSocket / SSE (Push)
Клиент держит соединение, сервис пушит готовность.
*   **Плюсы**: Мгновенное уведомление, без опроса.
*   **Минусы**: Stateful-сессии и усложнение инфраструктуры; провайдеры все равно REST-only.

### 3. Async Request-Response (polling)
Клиент получает `update_id` и опрашивает `GET /quotes/{update_id}`.
*   **Плюсы**: Stateless API, простое масштабирование, удобная дедупликация.
*   **Минусы**: Нужен polling на клиенте.

### 4. Вебхуки (Webhook callback)
Клиент передает `callback_url`, сервис уведомляет о готовности.
*   **Плюсы**: Без polling, быстрые уведомления, меньше запросов от клиента.
*   **Минусы**: Нужен публичный endpoint у клиента, сложнее безопасность (подписи), ретраи/фейлы доставки.

## Решение
Выбрана модель **Async Request-Response (Polling)**.

## Почему
1.  Провайдеры в основном REST-only, push не поддерживают.
2.  Stateless-поллинг проще масштабировать и поддерживать.
3.  Дедупликация естественно ложится на БД.
4.  Ожидание в несколько секунд приемлемо для фин. данных.

## Последствия
*   Клиентским приложениям необходимо реализовывать логику повторных запросов (polling) до получения статуса `SUCCESS` или `FAILED`.
*   Необходимо хранить историю запросов в БД для предоставления статусов.
