# Currency Quotes Service

## Описание
- **Асинхронное обновление котировок**: возможность запрашивать обновление курсов валютных пар без блокировки выполнения.
- **Фоновая обработка**: использование воркеров для получения данных от внешних провайдеров с поддержкой повторных попыток.
- **Кэширование**: использование Redis для быстрого доступа к последним полученным котировкам (read-through cache).
- **Дедупликация**: предотвращение избыточных запросов для одной и той же валютной пары в режиме реального времени.
- **Наблюдаемость**: структурированное логирование в формате JSON и отслеживание запросов с помощью Correlation ID.
- **Документация API**: автоматически генерируемая спецификация Swagger/OpenAPI.

## Быстрый старт

### Запуск в Docker
Для запуска всей инфраструктуры одной командой используйте Docker Compose. Передать API ключ (`QUOTESVC_EXTERNAL_API_KEY`) можно несколькими способами:

**Способ 1: Через файл .env (рекомендуется)**
Создайте файл `[.env](.env)` в корне проекта (на основе `[.env.example](.env.example)`) и добавьте туда ключ. Docker Compose автоматически подхватит его.
```bash
docker compose up --build
```

**Способ 2: Напрямую через командную строку**
```bash
QUOTESVC_EXTERNAL_API_KEY=your_key_here docker compose up --build
```

**Способ 3: Через переменные окружения сессии**
```bash
export QUOTESVC_EXTERNAL_API_KEY=your_key_here
docker compose up --build
```

Это запустит:
- **app**: HTTP API и воркер на порту 8080.
- **db**: PostgreSQL 18.1-alpine на порту 5432.
- **redis**: Redis 8.4.0-alpine на порту 6380.

### Локальный запуск
Для локального запуска необходимо установить Go версии 1.25.6+.
Также требуется настроить строки подключения (connection strings) для Redis и PostgreSQL в переменных окружения или файле `[.env](.env)`.

```bash
# 1. Склонировать репозиторий
git clone https://github.com/Alex-ttt/exchange-rate-quote-service.git
cd exchange-rate-quote-service

# 2. Настроить переменные окружения (создать [.env](.env))
cp .env.example .env
# Отредактируйте [.env](.env), указав QUOTESVC_DATABASE_HOST, QUOTESVC_REDIS_ADDR и QUOTESVC_EXTERNAL_API_KEY

# 3. Установить зависимости
go mod download

# 4. Запустить приложение
go run cmd/app/*.go
```

При локальном запуске (без Docker) убедитесь, что:
- **PostgreSQL** запущен и доступен по адресу, указанному в `QUOTESVC_DATABASE_HOST`.
- **Redis** запущен и доступен по адресу, указанному в `QUOTESVC_REDIS_ADDR`.

### Запуск из GoLand
В проекте настроены Run Configurations для GoLand, которые позволяют запускать приложение, тесты и зависимости в один клик.

## Минимальная конфигурация перед запуском
Перед запуском необходимо настроить API ключ для внешнего провайдера котировок.

**Рекомендуемый способ**: создать файл `[.env](.env)` в корне проекта на основе примера.

Обязательные переменные:
- `QUOTESVC_EXTERNAL_API_KEY`: ключ для доступа к API exchangerate.host.

Механизмы конфигурации:
- **Переменные окружения**: имеют наивысший приоритет (префикс `QUOTESVC_`).
- **Файл [.env](.env)**: загружается при старте приложения.
- **Файл [config.yaml](internal/config/config.yaml)**: содержит значения по умолчанию.

## Компоненты приложения

### API и Swagger UI
Приложение предоставляет REST API для работы с котировками.
- **Swagger UI** доступен по адресу: `http://localhost:8080/swagger/index.html` (если включено в конфиге).
- **Основные эндпоинты**:
    - `POST /quotes/update` — создание асинхронной задачи на обновление.
    - `GET /quotes/{update_id}` — получение статуса и результата обновления.
    - `GET /quotes/latest` — получение последней закэшированной котировки.

### Асинхронная обработка
Обновление котировок происходит асинхронно, чтобы не блокировать клиентские запросы. При вызове `/quotes/update` задача ставится в очередь, а клиент сразу получает `update_id`. Это позволяет масштабировать обработку внешних запросов независимо от API.

### Background worker (asynq)
Фоновый воркер использует библиотеку **Asynq** и **Redis** в качестве брокера сообщений.
- **Роль Redis**: хранение очереди задач и кэширование результатов.
- **Функции воркера**: получение задач из очереди, выполнение HTTP-запросов к провайдеру, обновление данных в БД и инвалидация/обновление кэша.
- **Запуск**: воркер запускается в том же процессе, что и API (в текущей конфигурации Docker Compose).

## Конфигурация (справочник)

| Переменная | Описание | Значение по умолчанию |
|------------|----------|-----------------------|
| `QUOTESVC_SERVER_PORT` | Порт HTTP сервера | `8080` |
| `QUOTESVC_DATABASE_HOST` | Хост PostgreSQL | `db` |
| `QUOTESVC_DATABASE_PORT` | Порт PostgreSQL | `5432` |
| `QUOTESVC_DATABASE_USER` | Пользователь БД | `postgres` |
| `QUOTESVC_DATABASE_PASSWORD` | Пароль БД | `postgres` |
| `QUOTESVC_DATABASE_NAME` | Имя базы данных | `quotesdb` |
| `QUOTESVC_REDIS_ADDR` | Адрес Redis | `redis:6380` |
| `QUOTESVC_EXTERNAL_API_KEY` | API ключ провайдера | (пусто) |
| `QUOTESVC_EXTERNAL_TIMEOUT_SEC` | Таймаут запроса к провайдеру | `5` |
| `QUOTESVC_CACHE_TTL_SEC` | Время жизни кэша котировок | `3600` |

## Healthcheck и Readiness

### Проверки на уровне контейнеров
В `[docker-compose.yml](docker-compose.yml)` настроены следующие проверки:
- **app**: `wget -qO- http://localhost:8080/healthz`
- **db**: `pg_isready`
- **redis**: `redis-cli PING`

### Эндпоинты приложения
- `GET /healthz` (Liveness): возвращает `200 OK`, если процесс запущен.
- `GET /readyz` (Readiness): возвращает `200 OK`, если есть соединение с PostgreSQL и Redis. В случае ошибки возвращает `503 Service Unavailable`.

## Тестирование
Проект включает в себя модульные (unit) и интеграционные тесты.

### Юнит-тесты
Проверяют изолированную логику компонентов без внешних зависимостей.
- **Handler & Middleware**: проверка корректности обработки HTTP-запросов, валидации входных данных и работы Correlation ID.
- **Service & Validator**: проверка бизнес-логики расчета котировок и правил валидации валютных пар.
- **Mocks**: использование моков для изоляции зависимостей (например, внешних API).

Запуск:
```bash
go test -v ./internal/...
```

### Интеграционные тесты
Проверяют взаимодействие компонентов с реальными инфраструктурными сервисами.
- **База данных (PostgreSQL)**: проверка миграций, корректности сохранения и получения данных, работы уникальных индексов и дедупликации.
- **Кэш (Redis)**: проверка стратегии кэширования (read-through) и инвалидации данных.
- **Testcontainers**: тесты автоматически запускают необходимые контейнеры (Postgres, Redis) перед началом работы, что гарантирует чистоту окружения.

Для запуска интеграционных тестов требуется установленный и запущенный **Docker**.

Запуск:
```bash
go test -v -tags=integration ./internal/integration/...
```

## Docker и CI/CD 
- **Docker**: проект содержит многоэтапный `[Dockerfile](Dockerfile)` для сборки легковесного образа на базе Alpine.
- **CI/CD**: настроен через GitHub Actions (`[.github/workflows/ci.yml](.github/workflows/ci.yml)`).
    - **Lint**: статическая проверка кода с использованием `golangci-lint` для обеспечения качества и стиля кода.
    - **Unit & Integration Tests**: автоматический запуск всех тестов в изолированном окружении с использованием Docker-сервисов для базы данных и кэша.
    - **Security Scan**: проверка кода на наличие уязвимостей с помощью `gosec`.
    - **API E2E Tests**: сценарий полной проверки работоспособности (End-to-End):
        - Сборка Docker-образа приложения.
        - Запуск всей инфраструктуры через `docker compose`.
        - Проверка доступности (Readiness check).
        - Тестирование реальных API-эндпоинтов с помощью `curl` (проверка валидации, создания задач и получения результатов).
    - **Swagger**: автоматическая проверка актуальности сгенерированной документации API.

## Возможные улучшения
- **Transactional Outbox**: использование паттерна Outbox для обеспечения гарантии доставки событий между базой данных и асинхронными задачами.
- **Выделение сервиса поддерживаемых валют**: вынос логики управления списком поддерживаемых валют в отдельный компонент на уровне БД.
- **Разделение на микросервисы**: разделение API и воркера на два независимых сервиса для их индивидуального масштабирования.
- Реализация поддержки нескольких провайдеров котировок для повышения отказоустойчивости.
- Добавление Grafana/Prometheus для расширенного мониторинга метрик воркера.
- Ограничение частоты запросов (Rate Limiting) для конкретных пользователей/IP.
